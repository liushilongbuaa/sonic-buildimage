#!/usr/bin/env python
#
# directed_bcastd
#
# Directed broadcast forwarding daemon for SONiC
#
#  The Linux kernel iis configured to disallow packets from one subnet to be
#  directly broadcast on another subnet. This daemon listens for directed
#  broadcast packets on all uplinks and forwards them to the broadcast IP of
#  the proper downlink VLAN interface.
#

try:
    import ast
    import argparse
    import binascii
    import datetime
    import netaddr
    import os
    import select
    import signal
    import socket
    import struct
    import subprocess
    import sys
    import syslog
    import time
    from fcntl import ioctl
except ImportError as err:
    raise ImportError("%s - required module not found" % str(err))

VERSION = "1.0"

SYSLOG_IDENTIFIER = "directed_bcastd"


# ========================== Syslog wrappers ==========================

def log_info(msg):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_INFO, msg)
    syslog.closelog()


def log_warning(msg):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_WARNING, msg)
    syslog.closelog()


def log_error(msg):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_ERR, msg)
    syslog.closelog()


# ========================== Signal Handling ==========================

def signal_handler(sig, frame):
    if sig == signal.SIGHUP:
        log_info("Caught SIGHUP - ignoring...")
        return
    elif sig == signal.SIGINT:
        log_info("Caught SIGINT - exiting...")
        sys.exit(128 + sig)
    elif sig == signal.SIGTERM:
        log_info("Caught SIGTERM - exiting...")
        sys.exit(128 + sig)
    else:
        log_warning("Caught unhandled signal '" + sig + "'")


# ============================== Classes ==============================

class Interface(object):
    """
    Represents a network interface

    Attributes:
        _name: Interface name
        _socket: Network socket descriptor for this interface
        _mac: MAC address of interface
        _fd: File descriptor in use by socket
    """
    ETH_P_ALL = 0x03
    RCV_TIMEOUT = 1000
    RCV_SIZE = 9100

    def __init__(self, iface_name):
        """
        Raises:
            IOError
        """
        self._name = iface_name
        self._socket = None
        self._mac = get_mac(iface_name)

    def __del__(self):
        if self._socket:
            self._socket.close()

    def bind(self):
        self._socket = socket.socket(socket.AF_PACKET,
                                     socket.SOCK_RAW,
                                     socket.htons(self.ETH_P_ALL))
        self._socket.bind((self._name, 0))
        self._socket.settimeout(self.RCV_TIMEOUT)

    def fd(self):
        return self._socket.fileno()

    def recv(self):
        return self._socket.recv(self.RCV_SIZE)

    def send(self, data):
        self._socket.send(data)

    def mac(self):
        return self._mac

    def name(self):
        return self._name


class DirectedBroadcaster(object):
    """
    Class which handles listening for subnet-directed broadcasts on uplink
    interfaces and forwards them to the appropriate destination VLAN interface

    Attributes:
        _vlan_bcast_to_iface_dict: A dictionary mapping VLAN broadcast IP to
            an Interface object for that VLAN interface
        _uplink_fd_to_iface_dict: A dictionary mapping socket file descriptor
            of an uplink interface to an Interface object for that interface
        _iface_update_timer_secs: Timer used to determine when to update view
            of interfaces
        _last_fwd_pkt_count_reset: Time _fwd_pkt_count was last reset
        _fwd_pkt_count: Current forwarded packet count, for rate limiting
    """
    MIN_PACKET_LEN = 64
    MAX_PACKETS_PER_SEC = 100
    IFACE_UPDATE_INTERVAL_SECS = 30.0

    def __init__(self):
        self._vlan_bcast_to_iface_dict = {}
        self._uplink_fd_to_iface_dict = {}
        self._iface_update_timer_secs = 0
        self._last_fwd_pkt_count_reset = datetime.datetime.min
        self._fwd_pkt_count = 0
        self._last_rate_exceeded_msg_logged = datetime.datetime.min

    def update_vlan_bcast_to_iface_dict(self):
        """
        Updates _vlan_bcast_to_iface_dict to reflect the current state of VLAN
        interfaces present on the device.

        """
        # Create a bcast-to-name dict of our previous vlans for diffing
        prev_vlan_bcast_to_name_dict = {}
        for bcast, iface in self._vlan_bcast_to_iface_dict.iteritems():
            prev_vlan_bcast_to_name_dict[bcast] = iface.name()

        # Obtain a map of each current VLAN's IPv4 broadcast address to its name
        vlan_bcast_to_name_dict = get_vlan_bcast_to_name_dict()

        # Create diffs of our previous and current lists
        bcasts_to_delete = set(prev_vlan_bcast_to_name_dict) - set(vlan_bcast_to_name_dict)
        bcasts_to_add = set(vlan_bcast_to_name_dict) - set(prev_vlan_bcast_to_name_dict)

        # Remove VLANs that have gone away
        for bcast in bcasts_to_delete:
            del self._vlan_bcast_to_iface_dict[bcast]

        # Add new VLANs
        for bcast in bcasts_to_add:
            try:
                iface = Interface(vlan_bcast_to_name_dict[bcast])
                iface.bind()
            except IOError as err:
                log_error("Failed to instantiate Interface object for interface "
                          "%s (%s)" % (vlan_bcast_to_name_dict[bcast], str(err)))
            else:
                self._vlan_bcast_to_iface_dict[bcast] = iface

    def update_uplink_fd_to_iface_dict(self):
        """
        Updates _uplink_fd_to_iface_dict to reflect the current state of uplink
        interfaces present on the device.
        """
        # Create a list of previous uplink names
        prev_uplink_names = []
        for fd, iface in self._uplink_fd_to_iface_dict.iteritems():
            prev_uplink_names.append(iface.name())

        # Obtain a list of names of all current IPv4 uplinks (i.e., non-VLAN
        # IPv4 interfaces)
        uplink_iface_names = get_uplink_iface_name_list()

        uplinks_to_delete = set(prev_uplink_names) - set(uplink_iface_names)
        uplinks_to_add = set(uplink_iface_names) - set(prev_uplink_names)

        # Remove uplinks that have gone away
        for name in uplinks_to_delete:
            for fd, iface in self._uplink_fd_to_iface_dict.iteritems():
                if iface.name() == name:
                    del self._uplink_fd_to_iface_dict[fd]
                    break

        # Add new uplinks
        uplink_ifaces = []
        for iface_name in uplinks_to_add:
            try:
                iface = Interface(iface_name)
                iface.bind()
            except IOError as err:
                log_error("Failed to instantiate Interface object for interface "
                          "%s (%s)" % (iface_name, str(err)))
            else:
                uplink_ifaces.append(iface)

        for iface in uplink_ifaces:
            self._uplink_fd_to_iface_dict[iface.fd()] = iface

    def recv_pkt_and_fwd_if_dir_bcast(self, recv_iface):
        """
        Receive a packet on recv_iface, check whether it is a subnet-directed
        broadcast packet; If so, forward the packet to the appropriate VLAN

        Args:
            recv_iface: Intreface object of uplink interface to receive on
        """
        pkt = recv_iface.recv()

        # Ignore runts
        if len(pkt) < self.MIN_PACKET_LEN:
            return

        # Ignore packets that aren't IPv4
        ip_version = ord(pkt[14]) >> 4
        if ip_version != 4:
            return

        # Retrieve the destination IP from the packet
        dst_ip = struct.unpack("!L", pkt[30:34])[0]

        # If the destination IP is not the broadcast IP of a VLAN subnet,
        # ignore the packet
        if dst_ip not in self._vlan_bcast_to_iface_dict.keys():
            return

        # Limit packet forwarding rate
        elapsed = datetime.datetime.now() - self._last_fwd_pkt_count_reset
        if elapsed > datetime.timedelta(seconds=1):
            self._last_fwd_pkt_count_reset = datetime.datetime.now()
            self._fwd_pkt_count = 0

        if self._fwd_pkt_count > self.MAX_PACKETS_PER_SEC:
            # Limit the frequency with which we log this state; prevent log flooding
            elapsed = datetime.datetime.now() - self._last_rate_exceeded_msg_logged
            if elapsed > datetime.timedelta(seconds=10):
                self._last_rate_exceeded_msg_logged = datetime.datetime.now()
                log_info("Packet forwarding rate exceeds limit. "
                         "Dropping directed broadcast packet(s).")
            return

        self._fwd_pkt_count += 1

        dst_if = self._vlan_bcast_to_iface_dict[dst_ip]
        dst_mac = binascii.unhexlify("ff" * 6)  # Overwrite dest mac with broadcast mac
        src_mac = dst_if.mac()                  # Overwrite source MAC with the interface MAC
        new_pkt = dst_mac + src_mac + pkt[12:]

        dst_if.send(new_pkt)

    def run(self):
        """
        Infinite loop that does the following:
            1. If enough time has elapsed, update the view of the device's interfaces
            2. Receive incoming packets on uplink interfaces
            3. Check if the packets are subnet-directed broadcasts. If so, forward
               them to the appropriate downlink VLAN interface
        """

        # Listen on all uplinks for subnet-directed broadcasts and attempt to
        # forward them to the appropriate VLAN
        while True:
            # If our interface update timer has expired, update our view of the
            # interfaces and reset the timer
            if self._iface_update_timer_secs <= 0:
                self.update_vlan_bcast_to_iface_dict()
                self.update_uplink_fd_to_iface_dict()
                self._iface_update_timer_secs = self.IFACE_UPDATE_INTERVAL_SECS

            # If we don't have any interfaces to receive on or send to, there's no
            # point in proceeding. Instead, just wait a bit and try updating our
            # view of the interfaces again
            if len(self._vlan_bcast_to_iface_dict) == 0 or len(self._uplink_fd_to_iface_dict) == 0:
                time.sleep(5)
                continue

            select_start_time = datetime.datetime.now()

            # Listen for incoming packets on our uplink interfaces
            (readlist, _, _) = select.select(self._uplink_fd_to_iface_dict.keys(),
                                             [],
                                             [],
                                             self._iface_update_timer_secs)

            # Update our timer accordingly
            select_elapsed_secs = (datetime.datetime.now() - select_start_time).total_seconds()
            self._iface_update_timer_secs -= select_elapsed_secs

            # Receive packets on all fd's that are ready for reading, and attempt
            # to forward any directed broadcasts
            for fd in readlist:
                recv_iface = self._uplink_fd_to_iface_dict[fd]
                self.recv_pkt_and_fwd_if_dir_bcast(recv_iface)


# ============================= Functions =============================

def print_hex(data):
    print " ".join("%02x" % ord(d) for d in data)


def get_if(iface, cmd):
    """
    Raises:
        IOError
    """
    s = socket.socket()
    ifreq = ioctl(s, cmd, struct.pack("16s16x", iface))
    s.close()

    return ifreq


def get_mac(iface):
    """
    Raises:
        IOError
    """
    SIOCGIFHWADDR = 0x8927  # Get hardware address
    return get_if(iface, SIOCGIFHWADDR)[18:24]


def get_iface_dict_from_config(iface_table_name):
    """
    Returns a dictionary of interface details as retrieved from SONiC
    device configuration
    """
    try:
        proc = subprocess.Popen(['sonic-cfggen', '-d', '-v', iface_table_name],
                                stdout=subprocess.PIPE,
                                shell=False,
                                stderr=subprocess.STDOUT)
        stdout = proc.communicate()[0].rstrip('\n')
    except (OSError, ValueError) as err:
        log_error("get_iface_dict_from_config(): "
                  "Failed to call sonic-cfggen (%s)" % str(err))
        return {}

    try:
        iface_dict = ast.literal_eval(stdout)
    except (ValueError, SyntaxError) as err:
        log_error("get_iface_dict_from_config(): "
                  "Failed to create iface_dict (%s)" % str(err))
        return {}

    return iface_dict


def get_vlan_bcast_to_name_dict():
    """
    Returns a dictionary where each key is an IPv4 broadcast IP address of a
    VLAN interface, and the value is the name of the VLAN interface
    """
    vlan_bcast_addrs = {}

    # Obtain a dictionary of all VLAN interface details
    iface_dict = get_iface_dict_from_config('VLAN_INTERFACE')

    # Each key is a tuple of the form (<iface_name>, <cidr>)
    for iface_name, cidr in iface_dict.keys():
        addr = netaddr.IPNetwork(cidr)
        if addr.version == 4:
            vlan_bcast_addrs[addr.broadcast.value] = iface_name

    return vlan_bcast_addrs


def get_uplink_iface_name_list():
    """
    Returns a list containing the names of all IPv4 uplinks (i.e., non-VLAN
    IPv4 interfaces)
    """
    uplink_iface_names = []

    # Obtain a dictionary of portchannel and non-VLAN interface details
    iface_dict = get_iface_dict_from_config('PORTCHANNEL_INTERFACE')
    iface_dict.update(get_iface_dict_from_config('INTERFACE'))

    # Each key is a tuple of the form (<iface_name>, <cidr>)
    for iface_name, cidr in iface_dict.keys():
        addr = netaddr.IPNetwork(cidr)
        if addr.version == 4:
            uplink_iface_names.append(iface_name)

    return uplink_iface_names


def main():
    log_info("Starting up...")

    if not os.geteuid() == 0:
        log_error("Must be root to run this daemon")
        print "Error: Must be root to run this daemon"
        sys.exit(1)

    # Register our signal handlers
    signal.signal(signal.SIGHUP, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Parse arguments
    parser = argparse.ArgumentParser(description="Daemon which forwards "
        "subnet-directed broadcast DHCP packets to the proper VLAN interface.")
    parser.add_argument("-v", "--version", action="store_true",
                        help="Print version information and exit")
    args = parser.parse_args()

    if args.version:
        print "version " + VERSION
        sys.exit(0)

    directed_broadcaster = DirectedBroadcaster()
    directed_broadcaster.run()


if __name__ == "__main__":
    main()
