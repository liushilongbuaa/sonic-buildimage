#!/usr/bin/perl -w

# Program to create a vegas netboot image for ROM/FreeDOS/DOS/Linux


BEGIN {
	push(@INC, './');
	push(@INC, '../tools/vnbigen/');
}

use strict;
use Getopt::Long;
use Socket;

use TruncFD;
use Nbi;
use Elf;

use constant;
use constant DEBUG => 1;

use vars qw($libdir $version $format $target $output $module $relocseg $relocsegstr $vendorinfoseg 
	    $checksumseg $progreturns $param $append $rootdir $rootmode $ipaddrs $ramdisk $vendorinfo  
	    $checksum $rdbase $simhd $dishd $squashfd $first16 $first32pm);

sub check_file
{
	my ($f, $status);

	$status = 1;
	foreach $f (@_) {
		if (!-e $f) {
			print STDERR "$f: file not found\n";
			$status = 0;
		} elsif (!-f $f) {
			print STDERR "$f: not a plain file\n";
			$status = 0;
		} elsif (!-r $f) {
			print STDERR "$f: file not readable\n";
			$status = 0;
		}
	}
	return ($status);
}

sub mknbi_rom ($)
{
	my ($format) = @_;
	my ($romdesc);

	$#ARGV >= 0 or die "Usage: progname romimage\n";
	return unless check_file($ARGV[0]);
	$format->add_header("mknbi-rom-$version", $relocseg + 0x3E0, 0x1000, 6);
	$romdesc = { file => $ARGV[0],
		segment => 0x1000,
		maxlen => 0x10000,
		id => 16,
		end => 1 };
	$format->add_segment($romdesc);
	$format->dump_segments();
	$format->copy_file($romdesc);
}

sub inet_aton_warn
{
	my ($ip);

	print STDERR "Warning: $_[0] cannot be resolved to an IP address\n" unless defined($ip = inet_aton($_[0]));
	return ($ip);
}

sub resolve_names
{
	my ($i);

	my ($client, $server, $gateway, $netmask, $hostname) = split(/:/, $_[0], 5);
	unless (defined($hostname)) {
		print STDERR "$_[0]: invalid specification\n";
		return ($_[0]);
	}
	$client = inet_ntoa($i) if defined($i = &inet_aton_warn($client));
	$server = inet_ntoa($i) if defined($i = &inet_aton_warn($server));
	$gateway = inet_ntoa($i) if defined($i = &inet_aton_warn($gateway));
	return (join(':', $client, $server, $gateway, $netmask, $hostname));
}

sub make_paramstring ($)
{
	my ($paramsize) = @_;
	my ($string, $nfsroot);

	# --param= overrides everything
	return ($param) if (defined($param));
	# String substitute various options, should do sanity checks also
	if (!defined($rootdir)) {
		$rootdir = '/dev/nfs';
	} elsif ($rootdir !~ m(^/dev/)) {
		$nfsroot = $rootdir;
		undef($nfsroot) if ($nfsroot eq 'kernel');
		$rootdir = '/dev/nfs';
	}
	if (defined($ipaddrs)) {
		if ($ipaddrs eq 'kernel') {
			undef($ipaddrs);
		} elsif ($ipaddrs !~ /^(rom|off|none|on|any|dhcp|bootp|rarp|both)$/) {
			$ipaddrs = &resolve_names($ipaddrs);
		}
	} elsif (!defined($ramdisk)) {
		print STDERR "Warning: The --ip option was not used; you may need it if you use NFSroot.\n\tPlease see the documentation.\n";
	}
	die "Ramdisk mode should be one of: top asis 0xNNNNNNNN (hex address)\n"
		if (defined($rdbase) and $rdbase !~ /^(top|asis|0x[\da-fA-F]{1,8})$/);
	# If rootmode is set, then check if it's rw or ro, and if so, use it
	if (defined($rootmode) and $rootmode !~ /^(rw|ro)$/) {
		die "-rootmode should be either rw or ro\n";
		undef($rootmode);
	}
	$string = defined($rootmode) ? $rootmode : 'rw';
	$string .= " root=$rootdir";
	$string .= " nfsroot=$nfsroot" if (defined($nfsroot));
	$string .= " ip=$ipaddrs" if (defined($ipaddrs));
	$string .= " rdbase=$rdbase" if (defined($rdbase));
	$string .= " $append" if (defined($append));
	return ($string);
}

use constant HEADER_SEG_OFFSET => 0x440;	# in units of 16 bytes
use constant START_OFFSET => 0x280;		# in units of 16 bytes
use constant START_MAX_LENGTH => 6144;
use constant PARAM_SEG_OFFSET => 0x400;		# in units of 16 bytes
use constant PARAM_MAX_LENGTH => 1024;
use constant FAKE_SEG_ADDRESS => 0x250000;      # in units of 16 bytes

sub mknbi_linux ($)
{
	my ($format) = @_;
	my ($startaddr, $setupfile, $setupfile32, $libfile, $kernelfile, $setupdesc);
	my ($paramseg, $paramstring, $bootseg, $block);
	my ($setupseg, $kernelseg, $kernellen, $ramdiskseg, $rdloc);
	my ($setupsects, $flags, $syssize, $swapdev,
		$ramsize, $vidmode, $rootdev, $sig, $ver, $bigker);

	$startaddr = sprintf("%#x", ($relocseg + START_OFFSET) * 0x10);
	$#ARGV >= 0 or die "Usage: progname kernelimage [ramdisk] \n";
	$kernelfile = $ARGV[0];
	return unless check_file( $kernelfile);
	if (defined($ramdisk = $ARGV[1])) {
	  return unless check_file($ramdisk);
	}
	if (defined($vendorinfo)) {
	  return unless check_file($vendorinfo);
	}
	if (defined($checksum)) {
	  return unless check_file($checksum);
	}
#        $format->add_pm_header("mknbi-linux-$version", $relocseg + HEADER_SEG_OFFSET, hex($startaddr), $progreturns);
        $format->add_header("mknbi-linux-$version", $relocseg + HEADER_SEG_OFFSET, hex($startaddr)/0x10, 0);
	$paramstring = &make_paramstring(PARAM_MAX_LENGTH);
	$paramseg = { string => $paramstring,
		      segment => $relocseg + PARAM_SEG_OFFSET,
		      maxlen => 1024,
		      id => 17 };
        $flags=1;
#	print STDERR 'setupsects flags syssize swapdev ramsize vidmode rootdev sig', "\n" if (DEBUG);
#	print STDERR "$setupsects $flags $syssize $swapdev $ramsize $vidmode $rootdev $sig\n" if (DEBUG);
	$bigker = ($flags & 0x1);
	print STDERR "$ARGV[0] \n";
	$kernelseg = { file => $ARGV[0],
		segment => $bigker ? 0x10000 : 0x1000,
		maxlen => $bigker ? 8 * 1024 * 1024 : 1024 * 512, 
		id => 20 };
	$ramdiskseg = { file => $ramdisk,
		segment => 0x50000,
		align => 4096,
		id => 21,
		maxlen => 256 * 1024 * 1024 };
	# If you remove this, remember to put the end = 1 in ending segment, whatever that will be
	$vendorinfoseg = { file => $vendorinfo,
			    segment => FAKE_SEG_ADDRESS,
			    id => 22, 
			    end => 1,
			  };
	
	$format->add_segment($paramseg);
	$kernellen = $format->add_segment($kernelseg);
	if (!$bigker and $kernellen > (($relocseg - 0x1000) * 16)) {
		print STDERR "Warning, zImage kernel may collide with Etherboot\n";
	}
	# Put ramdisk following kernel at next 4096 byte boundary
	$$ramdiskseg{'segment'} += (($kernellen + 0xFFF) & ~0xFFF) >> 4 if ($bigker);
	# should be 0, 1 or 2 depending on rdbase
	$format->add_segment($ramdiskseg, "\x00");
	$format->add_segment($vendorinfoseg);


	$format->dump_segments();

#	$format->copy_file($setupdesc);
	$format->copy_string($paramseg);
	$format->copy_file($kernelseg);
	$format->copy_file($ramdiskseg);
	$format->copy_file($vendorinfoseg);

	print STDERR "\n" if (DEBUG);
	print STDERR "id name    segment length file", "\n" if (DEBUG);
#	print STDERR "$$setupdesc{'id'} first   ", sprintf("0x%x",$$setupdesc{'segment'}), sprintf(" 0x%x",$$setupdesc{'maxlen'}), " $setupfile", "\n" if (DEBUG);
	print STDERR "$$paramseg{'id'} params  ", sprintf("0x%x",$$paramseg{'segment'}), sprintf(" 0x%x",$$paramseg{'maxlen'}), " $paramstring", "\n" if (DEBUG);
	print STDERR "$$kernelseg{'id'} kernel  ", sprintf("0x%x",$$kernelseg{'segment'}), sprintf(" 0x%x",$$kernelseg{'maxlen'}), " $kernelfile", "\n" if (DEBUG);
	print STDERR "$$ramdiskseg{'id'} ramdisk ", sprintf("0x%x",$$ramdiskseg{'segment'}), sprintf(" 0x%x",$$ramdiskseg{'maxlen'}), " $ramdisk", "\n" if (DEBUG);
	print STDERR "$$vendorinfoseg{'id'} append  ", sprintf("0x%x",$$vendorinfoseg{'segment'}), sprintf(" 0x%x",$$vendorinfoseg{'maxlen'}), " $vendorinfo", "\n" if (DEBUG);
}

sub get_geom ($$)
{
	my ($file, $block) = @_;
	my ($usedsize, $declsize, $firsttracksize, $geom_string, $fstype);
	my ($secttot, $secttrk, $heads, $bootid, $sig, $cyltot);

	($usedsize = $squashfd ? &TruncFD::truncfd($file) : -s $file) > 0
		or die "Error reading $file\n";
	(undef, $secttot, undef, $secttrk, $heads, undef, $bootid, undef,
		$fstype, $sig) = unpack('a19va3vva8Ca17a5@510a2', $$block);
	print STDERR "Warning, this doesn't appear to be a DOS boot sector\n"
		if ($sig ne "\x55\xAA");
	if ($simhd) {
		# change MediaDescriptor
		substr($$block, 0x15, 1) = "\xF8";
		# change HiddenSectors
		substr($$block, 0x1c, 4) = pack('V', $secttrk * $heads);
		# change the boot drive
		substr($$block, 0x24, 1) = "\x80";
	}
	$cyltot = $secttot / ($secttrk * $heads);
	$declsize = $secttot * 512;
	$firsttracksize = $secttrk * $heads * 512;
	print STDERR "Warning, used size $usedsize is greater than declared size $declsize\n"
		if ($usedsize > $declsize);
	$geom_string = pack('v3C2', $secttot, $secttrk, $cyltot, $simhd ? 0x80 : 0, $dishd);
	return ($usedsize, $declsize, $firsttracksize, $geom_string, $fstype);
}

sub mod_geom_string ($)
{
	my ($geom_string) = @_;
	my ($secttot, $secttrk, $cyltot, $simhd, $dishd) = unpack('v3C2', $geom_string);
	$cyltot++;	# for partition table
	return (pack('v3C2', $secttot, $secttrk, $cyltot, $simhd, $dishd));
}

sub encode_chs ($$$)
{
	my ($c, $h, $s) = @_;

	$s = ($s & 0x3F) | (($c & 0x300) >> 2);
	$c &= 0xFF;
	return ($h, $s, $c);
}

sub make_mbr ($$)
{
	my ($geom_string, $fstype) = @_;
	my ($heads, $bootsect);
	my ($secttot, $secttrk, $cyltot, $simhd, $x) = unpack('v3C2', $geom_string);

	$cyltot--;
	# $cyltot was incremented in mod_geom_string
	$heads = $secttot / ($secttrk * $cyltot);
	# bootsect is first sector of track 1
	$bootsect = $secttrk * $heads;
	# CHS stupidity:
	# cylinders is 0 based, heads is 0 based, but sectors is 1 based
	# 0x01 for FAT12, 0x04 for FAT16
	return (pack('@446C8V2@510v', 0x80, &encode_chs(1, 0, 1),
		$fstype eq 'FAT12' ? 0x01 : 0x04, &encode_chs($cyltot, $heads - 1, $secttrk),
		$bootsect, $secttot, 0xAA55));
}

sub mknbi_fdos ($)
{
	my ($format) = @_;
	my ($setupfile, $bootblock);
	my ($usedsize, $declsize, $firsttracksize, $geom_string, $fstype);
	my ($setupdesc, $kerneldesc, $firsttrackdesc, $bootdesc, $floppydesc);

	$setupfile = "$libdir/first.fdos";
	$#ARGV >= 1 or die "Usage: progname kernel.sys floppyimage\n";
	return unless check_file($setupfile, $ARGV[0], $ARGV[1]);
	$format->add_header("mknbi-fdos-$version", $relocseg + 0x200, $relocseg + 0x300, 0);
	$setupdesc = { file => $setupfile,
		segment => $relocseg + 0x300,
		maxlen => 4096,
		id => 16 };
	$kerneldesc = { file => $ARGV[0],
		segment => 0x60,
		maxlen => 0x40000,
		id => 17 };
	die "Ramdisk base should be of the form 0xNNNNNNNN (linear hex address)\n"
		if (defined($rdbase) and $rdbase !~ /^0x[\da-fA-F]{1,8}$/);
	$floppydesc = { file => $ARGV[1],
		segment => (defined($rdbase) ? (hex($rdbase) >> 4) : 0x11000),
		id => 18,
		end => 1 };
	$format->add_segment($setupdesc);
	$format->add_segment($kerneldesc);
	$format->peek_file($floppydesc, \$bootblock, 512) == 512
		or die "Error reading boot sector of $ARGV[1]\n";
	($usedsize, $declsize, $firsttracksize, $geom_string, $fstype)
		= &get_geom($ARGV[1], \$bootblock);
	$firsttrackdesc = { align => $firsttracksize };
	$$floppydesc{'fromoff'} = 512;
	$$floppydesc{'len'} = $usedsize;
	$$floppydesc{'len'} += $firsttracksize if $simhd;
	$$floppydesc{'maxlen'} = $declsize;
	$geom_string = &mod_geom_string($geom_string) if $simhd;
	$format->add_segment($floppydesc, $geom_string);
	$format->dump_segments();
	$format->copy_file($setupdesc);
	$format->copy_file($kerneldesc);
	if ($simhd) {
		$$firsttrackdesc{'string'} = &make_mbr($geom_string, $fstype);
		$format->copy_string($firsttrackdesc);
	}
	# write out modified bootblock, not the one in the file
	$bootdesc = { string => $bootblock };
	$format->copy_string($bootdesc);
	# Restore correct value of len and account for bootblock skipped
	$$floppydesc{'len'} = $usedsize - 512;
	$format->copy_file($floppydesc);
}

sub mknbi_dos ($)
{
	my ($format) = @_;
	my ($setupfile, $bootblock);
	my ($usedsize, $declsize, $firsttracksize, $geom_string, $fstype);
	my ($setupdesc, $firsttrackdesc, $bootdesc, $floppydesc);

	$setupfile = "$libdir/first.dos";
	$#ARGV >= 0 or die "Usage: progname floppyimage\n";
	return unless check_file($setupfile, $ARGV[0]);
	$format->add_header("mknbi-dos-$version", 0x1000, 0x1040, 0);
	$setupdesc = { file => $setupfile,
		segment => 0x1040,
		maxlen => 64512,
		id => 16 };
	die "Ramdisk base should be of the form 0xNNNNNNNN (linear hex address)\n"
		if (defined($rdbase) and $rdbase !~ /^0x[\da-fA-F]{1,8}$/);
	$floppydesc = { file => $ARGV[0],
		segment => (defined($rdbase) ? (hex($rdbase) >> 4) : 0x11000),
		id => 17,
		end => 1 };
	$format->add_segment($setupdesc);
	$format->peek_file($floppydesc, \$bootblock, 512) == 512
		or die "Error reading boot sector of $ARGV[0]\n";
	($usedsize, $declsize, $firsttracksize, $geom_string, $fstype)
		= &get_geom($ARGV[0], \$bootblock);
	$firsttrackdesc = { align => $firsttracksize };
	$$floppydesc{'fromoff'} = 512;
	$$floppydesc{'len'} = $usedsize;
	$$floppydesc{'len'} += $firsttracksize if $simhd;
	$$floppydesc{'maxlen'} = $declsize;
	$geom_string = &mod_geom_string($geom_string) if $simhd;
	$format->add_segment($floppydesc, $geom_string);
	$format->dump_segments();
	$format->copy_file($setupdesc);
	if ($simhd) {
		$$firsttrackdesc{'string'} = &make_mbr($geom_string, $fstype);
		$format->copy_string($firsttrackdesc);
	}
	# write out modified bootblock, not the one in the file
	$bootdesc = { string => $bootblock };
	$format->copy_string($bootdesc);
	# Restore correct value of len and account for bootblock skipped
	$$floppydesc{'len'} = $usedsize - 512;
	$format->copy_file($floppydesc);
}

sub mknbi_menu ($)
{
	my ($format) = @_;
	my ($menudesc, $datadesc);

	$#ARGV >= 0 or die "Usage: progname menudata\n";
	print STDERR "Warning: mkxxx-menu requires Etherboot 5.0 or later\n";
	return unless check_file("$libdir/menu", $ARGV[0]);
	# $progreturns == 1
	$format->add_pm_header("mknbi-menu-$version", $relocseg + 0x0, 0x10000, 1);
	$menudesc = { file => "$libdir/menu",
		segment => 0x1000,
		maxlen => 0x10000,
		id => 16 };
	$format->add_segment($menudesc);
	$datadesc = { file => $ARGV[0],
		segment => 0x2000,
		maxlen => 0x10000,
		id => 17,
		end => 1 };
	$format->add_segment($datadesc);
	$format->dump_segments();
	$format->copy_file($menudesc);
	$format->copy_file($datadesc);
}

$libdir = './';		# where config and auxiliary files are stored

$version = '1.2-6';
$simhd = 0;
$dishd = 0;
$squashfd = 1;
$first16 = 0;
$relocsegstr = '0x9000';
$progreturns = 0;
GetOptions('format=s' => \$format,
	'target=s' => \$target,
	'vendorinfo=s' => \$vendorinfo,
	'output=s' => \$output,
	'param=s' => \$param,
	'append=s' => \$append,
	'rootdir=s' => \$rootdir,
	'rootmode=s' => \$rootmode,
	'ip=s' => \$ipaddrs,
	'ipaddrs=s' => \$ipaddrs,
	'rdbase=s' => \$rdbase,
	'harddisk!' => \$simhd,
	'disableharddisk!' => \$dishd,
	'squash!' => \$squashfd,
	'first16!' => \$first16,
	'first32pm:s' => \$first32pm,
	'progreturns!' => \$progreturns,
	'relocseg=s' => \$relocsegstr);

if (!defined($format)) {
	print STDERR "No format specified with --format=\n";
	exit 1;
}
if (!defined($target)) {
	print STDERR "No target specified with --target=\n";
	exit 1;
}
if (!defined($vendorinfo)) {
	print STDERR "No vendorinfo specified with --vendorinfo=\n";
	exit 1;
}
if (defined($output)) {
	die "$output: $!\n" unless open(STDOUT, ">$output");
}
binmode(STDOUT);

if ($format eq 'nbi') {
	$module = Nbi->new($libdir);
} elsif ($format eq 'elf') {
	# ELF implies 32-bit and PM interface
	$first16 = 0;
	$first32pm = '' if !defined($first32pm);
	$module = Elf->new($libdir);
} else {
	print STDERR "Format $format not supported\n";
}
if ($relocsegstr eq '0x9000' or $relocsegstr eq '0x8000') {
	$relocseg = hex($relocsegstr);
} else {
	print STDERR "relocseg must be 0x9000 or 0x8000 only, setting to 0x9000\n";
	$relocseg = 0x9000;
}
if ($target eq 'rom') {
	&mknbi_rom($module);
} elsif ($target eq 'linux') {
	&mknbi_linux($module);
} elsif ($target eq 'fdos') {
	if ($simhd and $dishd) {
		print STDERR "Warning: --harddisk and --disableharddisk are incompatible\n";
	}
	&mknbi_fdos($module);
} elsif ($target eq 'dos') {
	if ($simhd and $dishd) {
		print STDERR "Warning: --harddisk and --disableharddisk are incompatible\n";
	}
	&mknbi_dos($module);
} elsif ($target eq 'menu') {
	&mknbi_menu($module);
} else {
	print STDERR "Target $target not supported\n";
}

close(STDOUT);
exit 0;

__END__

