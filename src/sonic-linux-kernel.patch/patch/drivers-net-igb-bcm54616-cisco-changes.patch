From c970ddd2474143f6cd51d2ac272e34711ffa04a9 Mon Sep 17 00:00:00 2001
From: uraghura <uraghura@contoso.com>
Date: Tue, 17 Aug 2021 14:58:52 +0000
Subject: [PATCH] drivers net igb bcm54616 cisco changes

---
 drivers/net/ethernet/intel/igb/e1000_82575.c  |   8 +-
 .../net/ethernet/intel/igb/e1000_defines.h    |   5 +
 drivers/net/ethernet/intel/igb/e1000_phy.c    | 242 ++++++++++++++++++
 drivers/net/ethernet/intel/igb/e1000_phy.h    |   5 +
 4 files changed, 258 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/intel/igb/e1000_82575.c b/drivers/net/ethernet/intel/igb/e1000_82575.c
index fdab974b2..f80aac66a 100644
--- a/drivers/net/ethernet/intel/igb/e1000_82575.c
+++ b/drivers/net/ethernet/intel/igb/e1000_82575.c
@@ -309,7 +309,11 @@ static s32 igb_init_phy_params_82575(struct e1000_hw *hw)
 		phy->ops.force_speed_duplex = igb_phy_force_speed_duplex_m88;
 		break;
 	case BCM54616_E_PHY_ID:
-		phy->type = e1000_phy_bcm54616;
+		phy->type		    = e1000_phy_bcm54616;
+		phy->ops.get_phy_info	    = igb_get_phy_info_bcm54616;
+		phy->ops.get_cable_length   = igb_get_cable_length_bcm54616;
+		phy->ops.force_speed_duplex = igb_phy_force_speed_duplex_bcm54616;
+		phy->ops.check_polarity	    = igb_check_polarity_bcm54616;
 		break;
 	default:
 		ret_val = -E1000_ERR_PHY;
@@ -1627,7 +1631,7 @@ static s32 igb_setup_copper_link_82575(struct e1000_hw *hw)
 		ret_val = igb_copper_link_setup_82580(hw);
 		break;
 	case e1000_phy_bcm54616:
-		ret_val = 0;
+		ret_val = igb_copper_link_setup_bcm54616(hw);
 		break;
 	default:
 		ret_val = -E1000_ERR_PHY;
diff --git a/drivers/net/ethernet/intel/igb/e1000_defines.h b/drivers/net/ethernet/intel/igb/e1000_defines.h
index dca671591..3c69fffa9 100644
--- a/drivers/net/ethernet/intel/igb/e1000_defines.h
+++ b/drivers/net/ethernet/intel/igb/e1000_defines.h
@@ -886,6 +886,11 @@
 #define M88E1512_E_PHY_ID    0x01410DD0
 #define BCM54616_E_PHY_ID    0x03625D10
 
+
+/* BCM54616 Specific registers */
+#define BCM54616_EXT_CTRL     0x10       /* BCM54616 Extended CTRL register */
+#define BCM54616_EXT_CTRL_MDIX_AUTO   0x4000
+
 /* M88E1000 Specific Registers */
 #define M88E1000_PHY_SPEC_CTRL     0x10  /* PHY Specific Control Register */
 #define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
diff --git a/drivers/net/ethernet/intel/igb/e1000_phy.c b/drivers/net/ethernet/intel/igb/e1000_phy.c
index ad2125e5a..74a0d57c3 100644
--- a/drivers/net/ethernet/intel/igb/e1000_phy.c
+++ b/drivers/net/ethernet/intel/igb/e1000_phy.c
@@ -848,6 +848,108 @@ s32 igb_copper_link_setup_igp(struct e1000_hw *hw)
 	return ret_val;
 }
 
+/**
+ *  igb_copper_link_setup_bcm54616 - Setup bcm54616 PHY's for copper link
+ *  @hw: pointer to the HW structure
+ *
+ *  Sets up Auto/MDI/MDI-X and LED modes for
+ *  BCM54616 PHY's.
+ **/
+s32 igb_copper_link_setup_bcm54616(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret_val;
+	u16 data;
+
+	if (phy->reset_disable) {
+		ret_val = 0;
+		goto out;
+	}
+
+	ret_val = phy->ops.reset(hw);
+	if (ret_val) {
+		hw_dbg("Error resetting the PHY.\n");
+		goto out;
+	}
+
+	/* Configure mdi-mdix settings */
+	ret_val = phy->ops.read_reg(hw, BCM54616_EXT_CTRL, &data);
+	if (ret_val)
+		goto out;
+
+	/*
+	* Options:
+	*   0 - Auto (default)
+	*   1 - MDI mode This intermediate state is not available BCM54616.
+	*   2 - MDI-X mode
+	*/
+	switch (phy->mdix) {
+	case 1:
+	case 2:
+		data |= BCM54616_EXT_CTRL_MDIX_AUTO;
+		break;
+	case 0:
+	default: /* Auto mode */
+		data &= (~BCM54616_EXT_CTRL_MDIX_AUTO);
+		break;
+	}
+	ret_val = phy->ops.write_reg(hw, BCM54616_EXT_CTRL, data);
+	if (ret_val)
+		goto out;
+
+	/*
+	 *  BCM54680 datasheet explains the registers.
+	 *  The way the LED pins are strapped 10/100 are not
+	 *  advertised.  So we do that below.  After doing
+	 *  that wait for a 2 sec or so for autoneg to complete
+	 */
+
+	ret_val = phy->ops.read_reg(hw, 0x4, &data);
+	if (ret_val)
+		goto out;
+
+	hw_dbg("checking for 10/100 Mbps mode for bcm54616: %x", data);
+	/* enable 10BaseT and 100BaseT autoneg unless it was already done */
+	if ((data & (0x1e << 4)) != (0x1e << 4)) {
+		/*
+		 * Due to way led pins are strapped which also act
+		 * as configuration input, we can't have the activity led
+		 * working right and have 10Mb and 100Mb advt enabled in
+		 * auto neg.  So we end up explicitly enabling them.
+		 */
+		data |= (0x1e << 4);
+		hw_dbg("Enabling 10/100 Advt \n");
+		phy->ops.write_reg(hw, 0x4, data);
+
+
+		/* set led1 selector to LINKSPD[2] so that the left LINK led
+		 * is lit when the link is up in either 100Mb or 1Gb link mode.
+		 * Howeven when connected to 10Mb link the left led wont be set
+		 * See broadcomm doc for more info
+		 */
+
+		/* read led selector 1 register */
+		data = 0xd << 10;
+		phy->ops.write_reg(hw, 0x1c, data);
+		phy->ops.read_reg(hw, 0x1c, &data);
+		hw_dbg("Led selector 1 reg %x \n", data);
+
+		/* Set the mode we want */
+		data &= ~0xf;
+		data |= (1 | ( 1 << 15));
+		phy->ops.write_reg(hw, 0x1c, data);
+
+
+		data = 0xd << 10;
+		phy->ops.write_reg(hw, 0x1c, data);
+		phy->ops.read_reg(hw, 0x1c, &data);
+		hw_dbg("Led selector 1 reg %x \n", data);
+	}
+
+out:
+	return ret_val;
+}
+
 /**
  *  igb_copper_link_autoneg - Setup/Enable autoneg for copper link
  *  @hw: pointer to the HW structure
@@ -1377,6 +1479,66 @@ static void igb_phy_force_speed_duplex_setup(struct e1000_hw *hw,
 	wr32(E1000_CTRL, ctrl);
 }
 
+/**
+ *  igb_phy_force_speed_duplex_bcm54616 - Force speed/duplex for BCM54616 PHY
+ *  @hw: pointer to the HW structure
+ *
+ * Calls the PHY setup function to force speed and duplex.  Clears the
+ * auto-crossover to force MDI manually.  Resets the PHY to commit the
+ * changes.  If time expires while waiting for link up, we reset the DSP.
+ * After reset, TX_CLK and CRS on Tx must be set.  Return successful upon
+ * successful completion, else return corresponding error code.
+ *
+ **/
+s32 igb_phy_force_speed_duplex_bcm54616(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret_val;
+	u16 phy_data = 0;
+	bool link;
+
+	hw_dbg("igb_phy_force_speed_duplex_bcm54616");
+
+	ret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_data);
+	if (ret_val)
+		goto out;
+
+	igb_phy_force_speed_duplex_setup(hw, &phy_data);
+
+	ret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_data);
+	if (ret_val)
+		goto out;
+
+	phy_data = 0;
+	ret_val = hw->phy.ops.read_reg(hw, BCM54616_EXT_CTRL, &phy_data);
+	if (ret_val)
+		goto out;
+
+	phy_data |= BCM54616_EXT_CTRL_MDIX_AUTO;
+	ret_val = hw->phy.ops.write_reg(hw, BCM54616_EXT_CTRL, phy_data);
+	if (ret_val)
+		goto out;
+
+	if (phy->autoneg_wait_to_complete) {
+		hw_dbg("Waiting for forced speed/duplex link on BCM54616 phy.\n");
+
+		ret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT,
+						     100000, &link);
+		if (ret_val)
+			goto out;
+
+		if (!link)
+			hw_dbg("Link taking longer than expected.\n");
+
+		/* Try once more */
+		ret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT,
+						     100000, &link);
+	}
+out:
+	return ret_val;
+}
+
+
 /**
  *  igb_set_d3_lplu_state - Sets low power link up state for D3
  *  @hw: pointer to the HW structure
@@ -1533,6 +1695,26 @@ s32 igb_check_polarity_m88(struct e1000_hw *hw)
 	return ret_val;
 }
 
+/**
+ *  igb_check_polarity_bcm54616 - Checks the polarity.
+ *  @hw: pointer to the HW structure
+ *
+ *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)
+ *
+ *  Polarity is determined based on the PHY specific status register.
+ **/
+s32 igb_check_polarity_bcm54616(struct e1000_hw *hw)
+{
+	s32 ret_val;
+
+	hw_dbg("igb_check_polarity_bcm54616");
+
+	/*According to SPEC there is no polarity invert except for 10baseT*/
+	ret_val = e1000_rev_polarity_normal;
+
+	return ret_val;
+}
+
 /**
  *  igb_check_polarity_igp - Checks the polarity.
  *  @hw: pointer to the HW structure
@@ -1824,6 +2006,26 @@ s32 igb_get_cable_length_m88_gen2(struct e1000_hw *hw)
 	return ret_val;
 }
 
+/**
+ *
+ *  igb_get_cable_length_bcm54616 - Determine cable length for m88 PHY
+ *  @hw: pointer to the HW structure
+ *
+ *  Reads the PHY specific status register to retrieve the cable length
+ *  BCM54616 doesn't talk about cable length in the datasheet.
+ *
+ **/
+s32 igb_get_cable_length_bcm54616(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret_val = 0;
+
+	hw_dbg("igb_get_cable_length_bcm54616");
+	phy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;
+	return ret_val;
+}
+
+
 /**
  *  igb_get_cable_length_igp_2 - Determine cable length for igp2 PHY
  *  @hw: pointer to the HW structure
@@ -1973,6 +2175,46 @@ s32 igb_get_phy_info_m88(struct e1000_hw *hw)
 	return ret_val;
 }
 
+/**
+ *  igb_get_phy_info_bcm54616 - Retrieve PHY information
+ *  @hw: pointer to the HW structure
+ *
+ *  Valid for only copper links.  Read the PHY status register (sticky read)
+ *  to verify that link is up.  Read the PHY special control register to
+ *  determine the polarity and 10base-T extended distance.  Read the PHY
+ *  special status register to determine MDI/MDIx and current speed.  If
+ *  speed is 1000, then determine cable length, local and remote receiver.
+ **/
+s32 igb_get_phy_info_bcm54616(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32  ret_val = 0;
+	bool link;
+
+	hw_dbg("igb_get_phy_info_bcm54616");
+
+	if (phy->media_type != e1000_media_type_copper) {
+		hw_dbg("Phy info is only valid for copper media\n");
+		ret_val = -E1000_ERR_CONFIG;
+		goto out;
+	}
+
+	ret_val = igb_phy_has_link(hw, 1, 0, &link);
+	if (ret_val)
+		goto out;
+
+	if (!link) {
+		hw_dbg("Phy info is only valid if link is up\n");
+		ret_val = -E1000_ERR_CONFIG;
+	}
+
+	/*FIXMEL: Add polarity related code*/
+	phy->cable_length = igb_get_cable_length_bcm54616(hw);
+
+out:
+	return ret_val;
+}
+
 /**
  *  igb_get_phy_info_igp - Retrieve igp PHY information
  *  @hw: pointer to the HW structure
diff --git a/drivers/net/ethernet/intel/igb/e1000_phy.h b/drivers/net/ethernet/intel/igb/e1000_phy.h
index 5894e4b1d..63970d74e 100644
--- a/drivers/net/ethernet/intel/igb/e1000_phy.h
+++ b/drivers/net/ethernet/intel/igb/e1000_phy.h
@@ -22,14 +22,18 @@ s32  igb_check_reset_block(struct e1000_hw *hw);
 s32  igb_copper_link_setup_igp(struct e1000_hw *hw);
 s32  igb_copper_link_setup_m88(struct e1000_hw *hw);
 s32  igb_copper_link_setup_m88_gen2(struct e1000_hw *hw);
+s32  igb_copper_link_setup_bcm54616(struct e1000_hw *hw);
 s32  igb_phy_force_speed_duplex_igp(struct e1000_hw *hw);
 s32  igb_phy_force_speed_duplex_m88(struct e1000_hw *hw);
+s32  igb_phy_force_speed_duplex_bcm54616(struct e1000_hw *hw);
 s32  igb_get_cable_length_m88(struct e1000_hw *hw);
 s32  igb_get_cable_length_m88_gen2(struct e1000_hw *hw);
+s32  igb_get_cable_length_bcm54616(struct e1000_hw *hw);
 s32  igb_get_cable_length_igp_2(struct e1000_hw *hw);
 s32  igb_get_phy_id(struct e1000_hw *hw);
 s32  igb_get_phy_info_igp(struct e1000_hw *hw);
 s32  igb_get_phy_info_m88(struct e1000_hw *hw);
+s32  igb_get_phy_info_bcm54616(struct e1000_hw *hw);
 s32  igb_phy_sw_reset(struct e1000_hw *hw);
 s32  igb_phy_hw_reset(struct e1000_hw *hw);
 s32  igb_read_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 *data);
@@ -55,6 +59,7 @@ s32  igb_get_cable_length_82580(struct e1000_hw *hw);
 s32  igb_read_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 *data);
 s32  igb_write_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 data);
 s32  igb_check_polarity_m88(struct e1000_hw *hw);
+s32  igb_check_polarity_bcm54616(struct e1000_hw *hw);
 
 /* IGP01E1000 Specific Registers */
 #define IGP01E1000_PHY_PORT_CONFIG        0x10 /* Port Config */
-- 
2.20.1

