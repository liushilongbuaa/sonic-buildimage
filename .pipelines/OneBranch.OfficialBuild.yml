schedules:
- cron: "0 8 * * *"
  displayName: Daily build
  branches:
    include:
    - internal
    - internal-202012
    - internal-201911
    - internal-201811
  always: false
trigger: none
pr: none
resources:
  repositories:
  - repository: acs-buildimage
    type: git
    name: One/Networking-acs-buildimage
    ref: internal
  - repository: cisco-8000
    type: github
    name: Cisco-8000-sonic/platform-cisco-8000
    endpoint: cisco-connection

name: $(TeamProject)_$(Build.DefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

pool: sonic-image-builder-1ES

parameters:
- name: 'jobFilters'
  type: object
  default:
  - vs
  - broadcom
  - mellanox
  - marvell-armhf
  - cisco-8000
- name: 'trusty8LinkPath'
  type: string
  default: 'default'

variables:
- group: SONIC-BUILD-VG-1
- name: PUBLISH_BLOB_PREFIX
  value: pipelines/$(Build.DefinitionName)/$(Build.SourceBranchName)
- template: .azure-pipelines/template-variables.yml@acs-buildimage
- template: .pipelines/azure-pipelines-repd-build-variables.yml@acs-buildimage

stages:
- stage: Build
  variables:
    BUILD_TIMESTAMP: $[format('{0:yyyyMMdd}.{0:HHmmss}', pipeline.startTime)]
    BRANCH_NAME: $(Build.SourceBranchName)
    BUILD_NUMBER: $(Build.BuildId)
    PLATFORM_ARCH: amd64
    PASSWORD: $(SONIC_PASSWORD)
    BUILD_OPTIONS: 'SONIC_BUILD_JOBS=4 ENABLE_DHCP_GRAPH_SERVICE=y SHUTDOWN_BGP_ON_START=y ENABLE_PFCWD_ON_START=y SONIC_DPKG_CACHE_SOURCE=/nfs/dpkg_cache/$(GROUP_NAME) ${{ variables.VERSION_CONTROL_OPTIONS }}'
    VERSION_PATH: target/sonic.version
    DOCKER_DATA_ROOT_FOR_MULTIARCCH: /data/march/docker
    PACKAGE_URL: "https://sonicstorage.blob.core.windows.net/packages"
  jobs:
  - template: .azure-pipelines/azure-pipelines-job-groups.yml@acs-buildimage
    parameters:
      scriptEnv:
        PASSWORD: '$(PASSWORD)'
      jobFilters: ${{ parameters.jobFilters }}
      preSteps:
        - template: .pipelines/prepare_agent.yml@acs-buildimage
        - template: .azure-pipelines/cleanup.yml@acs-buildimage
        - checkout: self
          clean: true
          submodules: recursive
          path: s
          displayName: 'Checkout code'
        - checkout: cisco-8000
          condition: eq(variables.GROUP_NAME, 'cisco-8000')
          submodules: recursive
          path: s/platform/cisco-8000
          displayName: 'Checkout cisco-8000'
        - script: |
            unset REGISTRY_SERVER
            git checkout -b $(Build.SourceBranchName)
            . functions.sh
            SONIC_VERSION=$(sonic_get_version)
            echo SONIC_VERSION=${SONIC_VERSION} > sonic.properties
            LATEST_TAG=$(git describe --tags --abbrev=0)
            [[ $LATEST_TAG == *-merge ]] && LATEST_TAG=
            mkdir -p target/release
            rm -f target/sonic-installers
            echo $SONIC_VERSION > $VERSION_PATH
            echo $LATEST_TAG > target/sonic.tag
            echo "SONIC_VERSION=$SONIC_VERSION, LATEST_TAG=$LATEST_TAG"
            echo "##vso[task.setvariable variable=SONIC_VERSION]$SONIC_VERSION"
            echo "##vso[task.setvariable variable=LATEST_TAG]$LATEST_TAG"
            ENABLE_DOCKER_BASE_PULL=y make PLATFORM=$(GROUP_NAME) PLATFORM_ARCH=$(PLATFORM_ARCH) $(BUILD_OPTIONS) configure
          displayName: 'Make configure'
      postSteps:
        - publish: $(System.DefaultWorkingDirectory)/target
          artifact: 'sonic-buildimage.$(GROUP_NAME)'
          displayName: "Archive sonic image"
        - publish: $(System.DefaultWorkingDirectory)/target
          condition: or(failed(), canceled())
          artifact: 'sonic-buildimage.$(GROUP_NAME)$(System.JobAttempt)'
          displayName: "Archive failed sonic image"
        - script: |
            for image in `ls target | grep -E "\.(swi|bin|raw|deb)$"`; do
              version_image=$(echo $image | sed -E "s/(-dbg\.\w+|\.\w+)$/-$(SONIC_VERSION)\1/")
              echo "$image,$version_image" >> target/sonic-installers
              cp -f target/$image target/$version_image
            done
          displayName: "Copy installers"
        - script: |
            export AZCOPY_LOG_LOCATION=$(pwd)/azcopy
            PUBLISH_PLATFORM_URL="https://$(SONIC_STORAGE_ACCOUNT).blob.core.windows.net/images/$(PUBLISH_BLOB_PREFIX)/$(GROUP_NAME)"
            PUBLISH_URL="$PUBLISH_PLATFORM_URL/$(Build.BuildId)$StorageSASKey"
            azcopy copy target "$PUBLISH_PLATFORM_URL/$(Build.BuildId)$StorageSASKey" --recursive=true --put-md5
            touch prev_build
            azcopy copy "$PUBLISH_PLATFORM_URL/latest_build$StorageSASKey" latest_build || true
            [ -f latest_build ] && mv latest_build prev_build
            echo $(Build.BuildId) > latest_build
            azcopy copy latest_build "$PUBLISH_PLATFORM_URL/latest_build$StorageSASKey"  --put-md5
            azcopy copy prev_build "$PUBLISH_PLATFORM_URL/prev_build$StorageSASKey"  --put-md5
          env:
            StorageSASKey: $(SONIC_STORAGE_SASKEY)
          displayName: "Publish to Azure Storage by azcopy"
        - task: SSH@0
          displayName: "Make soft links for trusty8"
          inputs:
            sshEndpoint: 'acs-trusty8'
            runOptions: 'inline'
            readyTimeout: '20000'
            inline: |
              echo "Make link for $(PUBLISH_BLOB_PREFIX)"
              LINK_FOLDERNAMES=.
              [ "$(SONIC_VERSION)" == "$(LATEST_TAG)" ] && LINK_FOLDERNAMES=". tagged"
              for link_foldername in $LINK_FOLDERNAMES; do
                LATEST_VERSION=
                PREVIOUS_VERSION=
                latest_path=/azmirrors/$(PUBLISH_BLOB_PREFIX)/$(GROUP_NAME)/$(BUILD_NUMBER)
                BRANCH_NAME=$(BRANCH_NAME)
                [[ "${{ parameters.trusty8LinkPath }}" != 'default' ]] && BRANCH_NAME=${{ parameters.trusty8LinkPath }}
                link_path=/data/$(dirname $(PUBLISH_BLOB_PREFIX))/$(GROUP_NAME)/$BRANCH_NAME/$link_foldername
                [ -e $link_path/latest ] && LATEST_VERSION=$(cat $link_path/latest/target/sonic.version)
                mkdir -p $link_path

                # Skip the change if the latest version is existed
                if [ "$LATEST_VERSION" = "$(SONIC_VERSION)" ]; then
                  echo "Skipped to update the symbol links for version $(SONIC_VERSION) in $link_path"
                  continue
                fi

                # Make soft links for latest and prev
                prev_link_path=$(realpath $link_path/latest)
                # If the latest version in the storage account is the same as the current build version, not update the prev link
                if [ -e $prev_link_path ] && [ "$LATEST_VERSION" != "$(SONIC_VERSION)" ]; then
                  [ -L $link_path/prev ] && PREVIOUS_VERSION=$(cat $link_path/prev/target/sonic.version)
                  ln -nsf "$prev_link_path" "$link_path/prev"
                fi

                ln -nsf "$latest_path" "$link_path/latest"

                # Make soft links for installers
                installers_path=$link_path/installers
                mkdir -p $installers_path
                ln -sf $latest_path/target/sonic.version $installers_path/sonic.version
                for installer in `cat $latest_path/target/sonic-installers`; do
                  image=$(echo $installer | cut -d, -f1)
                  version_image=$(echo $installer | cut -d, -f2)
                  ln -sf $latest_path/target/$version_image $installers_path/$image
                  ln -sf $latest_path/target/$version_image $link_path/$version_image
                  ln -sf latest/target/$image $link_path/$image
                  ln -sf prev/target/$image $link_path/$image.PREV.1
                done

                # Remove the old soft links
                if [ "$link_foldername" != "tagged" ]; then
                  echo "Remove the old symbol links in $link_foldername"
                  if [ -n "$PREVIOUS_VERSION" ]; then
                    rm -f $link_path/*"$PREVIOUS_VERSION"*
                  fi
                else
                  echo "Skipped to remove the old symbol links in $link_foldername"
                fi
              done
        - script: |
            SONIC_VERSION=$(cat $VERSION_PATH)
            PORT=443
            DOCKERS=$(ls target/docker-*.gz)
            BRANCH=$(Build.SourceBranchName)
            for f in $DOCKERS; do
              echo $f
              ./push_docker.sh $f $REGISTRY_SERVER_INTERNAL $PORT $REGISTRY_USERNAME "$REGISTRY_PASSWD" $SONIC_VERSION $BRANCH
              ./push_docker.sh $f $REGISTRY_SERVER_INTERNAL $PORT $REGISTRY_USERNAME "$REGISTRY_PASSWD" latest $BRANCH
              if [ "$UPLOAD_HL_ACR" = "true" ]; then
                ./push_docker.sh $f $HL_REGISTRY_SERVER $PORT $HL_REGISTRY_USERNAME "$HL_REGISTRY_PASSWD" $SONIC_VERSION $BRANCH
                ./push_docker.sh $f $HL_REGISTRY_SERVER $PORT $HL_REGISTRY_USERNAME "$HL_REGISTRY_PASSWD" latest $BRANCH
              fi
            done
          env:
            REGISTRY_PASSWD: $(REGISTRY_PASSWD)
            ACS_REGISTRY_PASSWD: $(ACS_REGISTRY_PASSWD)
            HL_REGISTRY_PASSWD: $(HL_REGISTRY_PASSWD)
            BUILD_NUMBER: $(Build.BuildId)
          displayName: "Publish to Docker Registry"
        - template: .pipelines/post-build-steps.yml@acs-buildimage
        - task: ComponentGovernanceComponentDetection@0
          condition: not(startsWith(variables['PLATFORM_ARCH'], 'armhf'))
        - script: |
            sudo rm -rf fsroot
            docker rmi -f $(docker images docker-* -a -q | grep docker-) || true
          displayName: "CleanUp"
      jobGroups:
        - name: vs
          script: |
            set -ex
            make $(BUILD_OPTIONS) SONIC_DPKG_CACHE_METHOD=wcache PASSWORD=$PASSWORD target/sonic-vs.bin target/sonic-vs.img.gz
            gzip -kd target/sonic-vs.img.gz
            SONIC_RUN_CMDS="qemu-img convert target/sonic-vs.img -O vhdx -o subformat=dynamic target/sonic-vs.vhdx" make sonic-slave-run
            rm target/sonic-vs.img
        - name: generic
          script: |
            OPTIONS="$(BUILD_OPTIONS) SONIC_DPKG_CACHE_METHOD=wcache PASSWORD=$PASSWORD"
            make $OPTIONS target/sonic-generic.bin
        - name: broadcom
          timeoutInMinutes: 1440
          script: |
            set -ex
            OPTIONS="$(BUILD_OPTIONS) SONIC_DPKG_CACHE_METHOD=wcache PASSWORD=$PASSWORD"

            echo "==== Building slim images"
            echo "INCLUDE_MUX = n" >> rules/config.user
            echo "INCLUDE_KUBERNETES = n" >> rules/config.user
            make $OPTIONS target/sonic-broadcom.bin
            mv target/sonic-broadcom.bin target/sonic-broadcom-slim.bin
            echo "INCLUDE_ACMS = y" > rules/config.user
            echo "INCLUDE_MUX = n" >> rules/config.user
            echo "INCLUDE_KUBERNETES = n" >> rules/config.user
            echo "INCLUDE_RESTAPI = y" >> rules/config.user
            make $OPTIONS target/sonic-aboot-broadcom.swi
            mv target/sonic-aboot-broadcom.swi target/sonic-aboot-broadcom-slim.swi
            rm rules/config.user
            echo "==== Finished building slim images"

            echo "==== Building regular images"
            make $OPTIONS INCLUDE_RESTAPI=y target/sonic-broadcom.bin target/sonic-aboot-broadcom.swi target/sonic-broadcom.raw
            mv target/sonic-broadcom.bin target/sonic-aboot-broadcom.swi target/sonic-broadcom.raw target/release/
            make $OPTIONS target/debs/buster/python-saithrift_0.9.4_amd64.deb
            cp target/debs/buster/python-saithrift_0.9.4_amd64.deb target/
            echo "==== Finished building regular images"

            echo "==== Building syncd-rpc docker"
            make $OPTIONS ENABLE_SYNCD_RPC=y target/docker-syncd-brcm-rpc.gz
            echo "==== Finished building syncd-rpc docker"

            echo "==== Building saiserver docker"
            make $OPTIONS ENABLE_SYNCD_RPC=y target/docker-saiserver-brcm.gz
            echo "==== Finished building saiserver docker"

            echo "==== Building brcm saiserverv2 docker and sai python header"
            make BLDENV=buster SAITHRIFT_V2=y INSTALL_DEBUG_TOOLS=y $OPTIONS -f Makefile.work target/docker-saiserverv2-brcm.gz
            cp target/debs/buster/python-saithriftv2_0.9.4_amd64.deb target/python-saithriftv2_0.9.4_amd64.deb
            echo "==== Finished building brcm saiserverv2 docker and sai python header"

            echo "==== Building one debug image"
            make $OPTIONS INSTALL_DEBUG_TOOLS=y target/sonic-broadcom.bin
            mv target/sonic-broadcom.bin target/sonic-broadcom-dbg.bin
            echo "==== Finished building one debug image"

            mv target/release/* target/
        - name: mellanox
          script: |
            OPTIONS="$(BUILD_OPTIONS) SONIC_DPKG_CACHE_METHOD=wcache INCLUDE_RESTAPI=y INCLUDE_VNET_MONITOR=y PASSWORD=$PASSWORD"
            make $OPTIONS INCLUDE_NAT=n INCLUDE_RESTAPI=y INCLUDE_VNET_MONITOR=y target/sonic-mellanox.bin
            make $OPTIONS INCLUDE_NAT=n ENABLE_SYNCD_RPC=y INCLUDE_RESTAPI=y INCLUDE_VNET_MONITOR=y target/docker-syncd-mlnx-rpc.gz || true
            mv target/sonic-mellanox.bin target/release/
            cp target/debs/buster/python-saithrift_0.9.4_amd64.deb target/python-saithrift_0.9.4_amd64.deb

            make $OPTIONS INSTALL_DEBUG_TOOLS=y INCLUDE_RESTAPI=y INCLUDE_VNET_MONITOR=y INCLUDE_NAT=n target/sonic-mellanox.bin
            mv target/sonic-mellanox.bin target/sonic-mellanox-dbg.bin
            mv target/release/* target/
        - name: barefoot
          script: |
            set -ex
            sudo modprobe overlay
            OPTIONS="$(BUILD_OPTIONS) ENABLE_NAT=n INCLUDE_RESTAPI=y PASSWORD=$PASSWORD"
            make $OPTIONS ENABLE_SYNCD_RPC=y target/docker-syncd-bfn-rpc.gz
            make $OPTIONS target/sonic-barefoot.bin target/sonic-aboot-barefoot.swi
        - name: marvell-armhf
          pool: sonic-armhf
          timeoutInMinutes: 2160
          variables:
            PLATFORM_ARCH: armhf
          script: |
            echo "INCLUDE_SFLOW = y" > rules/config.user
            OPTIONS="$(BUILD_OPTIONS) PASSWORD=$PASSWORD"
            make $OPTIONS target/sonic-marvell-armhf.bin
        - name: cisco-8000
          variables:
            TERM: ''
          steps:
          - script: |
              cisco_ref=$(cat platform/checkout/cisco-8000.ini | grep '^ref=' | cut -d= -f2)
              echo "The cisco 8000 release version is $cisco_ref"
              echo "##vso[task.setvariable variable=cisco.ref]$cisco_ref"
            displayName: 'Export cisco release version'
          - task: DownloadGitHubRelease@0
            inputs:
              connection: cisco-connection
              userRepository: Cisco-8000-sonic/platform-cisco-8000
              defaultVersionType: specificTag
              version: $(cisco.ref)
              itemPattern: 'artifactory-*.tar.gz'
              downloadPath: '$(System.ArtifactsDirectory)'
          - script: |
              tar xvfz $(System.ArtifactsDirectory)/artifactory-*.tar.gz -C platform/cisco-8000
            displayName: 'Setup cisco artifacts'
          - script: |
              if [ ! -e platform/cisco-8000/device/x86_64-8102_64h_o-r0/Cisco-8102-C64 ]; then
                echo "hwsku Cisco-8102-C64 doesn't exist, copy from 64x100Gb"
                cp -r platform/cisco-8000/device/x86_64-8102_64h_o-r0/64x100Gb platform/cisco-8000/device/x86_64-8102_64h_o-r0/Cisco-8102-C64
              else
                echo "hwsku Cisco-8102-C64 exist"
              fi
            displayName: 'Setup cisco hwsku Cisco-8102-C64'
          - script: |
              set -ex
              filename=$(find platform/cisco-8000/artifactory/sonic -name cisco-* -type f | head -n 1)
              if [ -z "$filename" ]; then
                echo "Cisco sai package not found" 1>&2
                exit 1
              fi
              cd $(dirname $filename)
              echo "PWD=$(pwd)"
              ls -l cisco-*.deb
              while read -r package; do
                # Cisco version format: <VERSION>-sai-<sai-ver>-<distribution>-<COMMIT HASH>
                # The <sai-ver> may contain several values in one build, the part is skipped when publishing to storage
                # See https://github.com/Cisco-8000-sonic/sdk/blob/master/azure-pipelines.yml
                # The $PACKAGE_URL is only accessible for AZP
                version=$(echo $package | awk -F_ '{print $(NF-1)}' | cut -d- -f1,2,4,5)
                package_url="$PACKAGE_URL/sai/ciscosai/master/$version/$package"
                echo "Override package $package from $package_url"
                wget "$package_url$StorageSASKey" -O "$package"
              done < <(ls cisco-*.deb)
            env:
              StorageSASKey: $(SONIC_PUBLIC_STORAGE_SASKEY)
            condition: ne(variables['Build.Reason'], 'PullRequest')
            displayName: "Override cisco sai packages"
          - script: |
              set -ex
              OPTIONS="$(BUILD_OPTIONS) ENABLE_NAT=n INCLUDE_RESTAPI=y INCLUDE_VNET_MONITOR=y PASSWORD=$PASSWORD"
              make $OPTIONS target/sonic-cisco-8000.bin
              make $OPTIONS ENABLE_SYNCD_RPC=y target/docker-syncd-cisco-rpc.gz
            env:
              PASSWORD: '$(PASSWORD)'
            displayName: JobScript
